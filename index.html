<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title id="page-title">Falling Tile Matching Game</title>
    <style>
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f0f0f0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
    touch-action: none;
}

#game-container {
    width: 100%;
    max-width: 550px;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh; /* Make game container take full viewport height */
    max-height: 100vh; /* Ensure it doesn't exceed viewport */
    padding: 5px; /* Add a little padding around the game container */
    box-sizing: border-box;
}

/* Modal Styles */
.modal {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.1); /* Darker background for better contrast */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    padding: 15px; /* Add padding for smaller screens */
    box-sizing: border-box;
}

.modal-content {
    background-color: #fff;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 90%; /* Ensure modal fits on smaller screens */
    max-height: 90vh; /* Prevent modal from being too tall */
    overflow-y: auto; /* Allow scrolling if content overflows */
}

.modal-content h2 {
    margin-top: 0;
    color: #333;
}

.modal-content p {
    text-align: left; /* Align rules to the left for readability */
    margin-bottom: 0px;
    line-height: 1.6;
    color: #555;
}

.modal-content ul {
    text-align: left;
    padding-left: 20px; /* Indent list items */
    margin-bottom: 15px;
}

.modal-content li {
    margin-bottom: 8px;
    line-height: 1.5;
    color: #555;
}

.modal-content button {
    padding: 10px 20px;
    margin: 10px;
    border: none;
    border-radius: 5px;
    background-color: #4CAF50;
    color: white;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.modal-content button:hover {
    background-color: #45a049;
}

/* Specific style for How to Play button */
#how-to-play-btn {
    background-color: #2196F3; /* Blue background */
}

#how-to-play-btn:hover {
    background-color: #1c7cd6; /* Darker blue on hover */
}

.confirm-btn-yes {
    background-color: #F44336 !important; /* Red for confirmation */
}
.confirm-btn-yes:hover {
    background-color: #d32f2f !important; /* Darker red */
}
.confirm-btn-no {
    background-color: #757575 !important; /* Grey for cancel */
}
.confirm-btn-no:hover {
    background-color: #616161 !important; /* Darker grey */
}

.language-selector-container {
    margin-top: 15px;
    margin-bottom: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.language-selector-container label {
    margin-right: 8px;
    font-size: 1em;
    color: #555;
}

.language-selector-container select {
    padding: 5px 8px;
    border-radius: 4px;
    border: 1px solid #ccc;
    font-size: 0.95em;
}


/* Game Interface Styles */
#game-interface {
    display: flex; /* CHANGED: Use flexbox */
    flex-direction: column; /* CHANGED: Stack children vertically */
    align-items: center; /* CHANGED: Center children like stats-area if its width is not 100% of parent*/
    width: 100%; /* Make game-interface take full width of game-container */
    flex-grow: 1; /* Allow game interface to take available vertical space */
    overflow: hidden; /* Prevent internal scrolling if content overflows due to sizing issues */
    /* display: none; is handled by JS */
}

#stats-area {
    display: flex;
    flex-direction: column; /* Stack rows vertically */
    width: 100%;
    padding: 8px 0;
    margin-bottom: 8px;
    background-color: #e0e0e0;
    border-radius: 5px;
    font-size: clamp(0.8em, 2.5vw, 1.2em);
    flex-shrink: 0;
}

.stats-row {
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 100%;
}

.stats-row:first-child {
    margin-bottom: 5px; /* Add some space between rows */
}


#score-area, #highscore-area, #combo-area, #timer-area-container { /* Renamed timer-area to timer-area-container */
    padding: 0 5px;
    text-align: center;
    flex-grow: 1;
    white-space: nowrap;
}

#timer-area-container { /* Styles for the container of timer text and bar */
    display: flex;
    align-items: center;
    justify-content: center;
}


#time-bar-container {
    width: clamp(70px, 50vw, 200px); /* Responsive width */
    height: 15px; /* Adjusted height */
    background-color: #ccc;
    border-radius: 5px;
    margin-left: 8px; /* Adjusted margin */
    overflow: hidden;
}

#time-bar {
    height: 100%;
    width: 100%;
    background-color: #4CAF50;
    border-radius: 5px;
	transition: background-color 0.2s linear;
}


#game-display-area {
    display: flex;
    width: 100%;
    flex-grow: 1; /* Allow this area to take remaining space after stats */
    min-height: 0; /* Important for flex children that need to scroll or manage overflow */
}

#pairs-preview-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: top;
    margin-top: 20px;
    padding-right: clamp(10px, 3vw, 20px); /* Responsive padding */
    flex-shrink: 0;
    flex-basis: clamp(70px, 20vw, 120px); /* Adjusted base width for save button */
    position: relative;
}

.pair-container {
    margin-bottom: clamp(10px, 3vh, 20px); /* Adjusted margin */
    text-align: center;
}

.pair-label {
    font-size: clamp(0.9em, 2vw, 1.1em);
    margin-top: 15px;
    margin-bottom: 5px;
}

#current-pair, #next-pair {
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* The main container for the "Next" label and the "Next" pair blocks */
.pair-container.next-pair-container {
    /* text-align: center; if you want the label centered above */
    /* margin-bottom: clamp(10px, 3vh, 20px); Keep your desired spacing */
}

/* The label for "Next" */
#next-label {
    position: relative;
    z-index: 3;
    margin-bottom: 5px;
}

#next-pair {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    /* No specific z-index needed here, its children will handle it */
}

/* Styling for the actual "Next" blocks (#next-secondary, #next-primary) */
#next-pair > .block { /* Target direct children blocks of #next-pair */
    position: relative;
    z-index: 2;         /* HIGHER z-index: These blocks go ON TOP of next-next */
    /* width, height, etc., are already set by .block and JS */
}

/* Container for the "Next-Next" preview */
.next-next-pair-container {
    position: absolute;   /* Positioned relative to #next-pair */
    top: 10px;            /* Adjust: Offset DOWN from the top of #next-pair blocks */
    left: 10px;           /* Adjust: Offset RIGHT from the left of #next-pair blocks */
    width: 100%;          /* Takes the width of #next-pair for alignment */
    opacity: 0.5;         /* Faded */
    z-index: 1;           /* LOWER z-index: This goes BEHIND #next-pair > .block */
    display: flex;
    justify-content: center; /* Centers the #next-next-pair div inside */
}

/* The div holding the next-next blocks */
#next-next-pair {
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* Adjust pairs-preview-area if needed to accommodate the new preview */
#pairs-preview-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: top;
    margin-top: 20px;
    padding-right: clamp(10px, 3vw, 20px);
    flex-shrink: 0;
    flex-basis: clamp(70px, 20vw, 120px);
    position: relative;
}

#save-pair-btn {
    display: flex; /* Changed by JS to flex when visible */
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 8px;
    margin: 10px auto; /* Adjusted margin, was 10px auto */
    margin-top: 10px; /* Reduce top margin if next-next makes it too low */
    border: none;
    border-radius: 5px;
    background-color: #e0e0e0;
    cursor: pointer;
    width: clamp(60px, 90%, 110px); /* Responsive width */
    font-size: clamp(0.9em, 2vw, 1.1em);
    box-sizing: border-box;
    position: relative; /* Add relative positioning */
    z-index: 5;         /* Ensure it's above the next-next pair if overlapping occurs */
}

#save-pair-btn .save-btn-text {
    margin-bottom: 5px;
	font-style: italic;
    /* font-weight: bold; */
}

#save-pair-btn .save-btn-blocks-container {
    display: flex;
    flex-direction: column;
    align-items: center;
}

#save-pair-btn .save-btn-blocks-container .block {
    margin: 1px 0; /* Minimal margin for stacked blocks */
    /* JS will set width, height, borderRadius, and color class */
    /* box-shadow from .block class will apply */
}


#end-game-btn {
    padding: 10px 10px;
    margin: 10px auto; /* Ensure consistent margin */
    border: none;
    border-radius: 5px;
    background-color: #ec4d45; /* Red */
    color: white;
    font-size: 16px;
    cursor: pointer;
    width: clamp(60px, 90%, 110px); /* Match save button width */
    box-sizing: border-box;
}
#end-game-btn:hover {
    background-color: #d32f2f;
}

.block {
    /* width and height will be set by JS for preview blocks to be relative to cell size */
    margin: 1px 0;
    border-radius: clamp(4px, 1vw, 8px); /* Responsive border-radius */
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: white;
    position: relative;
    box-shadow:
        inset 2px 2px 3px rgba(255, 255, 255, 0.3),
        inset -2px -2px 3px rgba(0, 0, 0, 0.2),
        2px 2px 5px rgba(0, 0, 0, 0.3);
}


.primary-block::after {
    content: '×'; /* Cross mark */
    font-size: 1.5em; /* Adjust size of cross mark */
    color: rgba(255, 255, 255, 0.7); /* Semi-transparent white */
    position: absolute;
}

/* Block Colors */
.block.green { background-color: #4CAF50; }
.block.blue { background-color: #2196F3; }
.block.red { background-color: #F44336; }
.block.purple { background-color: #9C27B0; }
.block.orange { background-color: #FF9800; }

#playfield-container {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: top; /* Center the playfield vertically if there's extra space */
    margin-top: 15px;
    min-width: 0; /* Important for flex children */
}

#playfield {
    display: grid;
    grid-template-columns: repeat(6, var(--cell-size));
    grid-template-rows: repeat(12, var(--cell-size));
    background-color: #d3d3d3;
    border: 2px solid #cccccc;
    border-radius: 8px;
    gap: 2px;
    padding: 2px;
    position: relative;
    overflow: hidden;
    max-width: 100%; /* Ensure it doesn't overflow its container if calculation is off */
    max-height: 100%;
    box-sizing: content-box; /* Important if padding is used to represent grid lines border */
}

.playfield-cell {
    background-color: #e0e0e0;
}

.playfield-block {
    position: absolute;
    /* width, height, left, top set by JS */
    z-index: 10;
    margin: 0 !important;
}

.line {
  width: 65px;
  height: 0;
  border: 1px solid #C4C4C4;
  margin: 3px auto 5px auto; /* Added auto for horizontal centering and bottom margin */
  display:block; /* Ensure it takes up its own line */
}

.preview-block {
    opacity: 0.5; /* Transparent for preview */
    z-index: 5;
}

.clearing {
    animation: clearAnimation 0.5s forwards;
}

@keyframes clearAnimation {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.2); opacity: 0.5; }
    100% { transform: scale(0); opacity: 0; }
}

/* Responsive adjustments */
@media (max-width: 600px) {
    #stats-area {
        font-size: 1em;
    }
     .stats-row {
        flex-wrap: wrap;
    }
    #timer-area-container {
        flex-basis: 100%;
        margin-top: 5px;
    }
}
@media (max-width: 300px) {
    #stats-area {
        font-size: 0.9em;
    }
     .stats-row {
        flex-wrap: wrap;
    }
    #timer-area-container {
        flex-basis: 100%;
        margin-top: 5px;
    }
    #time-bar-container {
        width: 90px;
    }
}
    </style>
</head>
<body>
    <div id="game-container">
        <div id="mode-selection-modal" class="modal">
            <div class="modal-content">
                <h2 id="main-menu-title">Falling Tile Matching</h2>
                <button id="relax-mode-btn">Relax Mode</button>
                <button id="timed-mode-btn">Timed Mode</button>
                <button id="pressure-mode-btn">Pressure Mode</button>
                <button id="how-to-play-btn">How to Play</button>
                <div class="language-selector-container">
                    <label for="language-selector" id="language-label">Language:</label>
                    <select id="language-selector">
                        <option value="en">English</option>
                        <option value="vi">Tiếng Việt</option>
                    </select>
                </div>
            </div>
        </div>


        <div id="how-to-play-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <h2 id="htp-title">How to Play</h2>
                <p><span id="htp-objective-label-strong"><strong>Objective:</strong></span> <span id="htp-objective-text">Score points by matching groups of 4 or more same-colored blocks!</span></p>

                <p><strong id="htp-gameplay-label">Gameplay:</strong></p>
                <ul>
                    <li id="htp-gameplay-rule1"></li>
                    <li id="htp-gameplay-rule2"></li>
                    <li id="htp-gameplay-rule3"></li>
                    <li id="htp-gameplay-rule4"></li>
                    <li id="htp-gameplay-rule5"></li>
                    <li id="htp-gameplay-rule6"></li>
                    <li id="htp-gameplay-rule7"></li>
                    <li id="htp-gameplay-rule8"></li>
                </ul>
                <p><strong id="htp-gamemodes-label">Game Modes:</strong></p>
                <ul>
                    <li><strong id="htp-relaxmode-label">Relax Mode:</strong> <span id="htp-relaxmode-desc"></span></li>
                    <li><strong id="htp-timedmode-label">Timed Mode:</strong> <span id="htp-timedmode-desc"></span></li>
                    <li><strong id="htp-pressuremode-label">Pressure Mode:</strong> <span id="htp-pressuremode-desc"></span></li>
                </ul>
                <button id="close-how-to-play-btn">Got it!</button>
            </div>
        </div>


        <div id="game-interface" style="display: none;">
            <div id="stats-area">
                <div class="stats-row">
                    <div id="score-area"><span class="label">Score: </span><span id="score">0</span></div>
                    <div id="highscore-area"><span class="label">High Score: </span><span id="highscore">0</span></div>
                    <div id="combo-area"><span class="label">Combo </span><span id="combo-value-display">0x</span></div>
                </div>
                <div class="stats-row">
                    <div id="timer-area-container" style="display: none;"><span class="label">Time: </span>&nbsp;<span id="time-left">0.0</span>
                        <div id="time-bar-container">
                            <div id="time-bar"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="game-display-area">
                <div id="pairs-preview-area">
                    <div class="pair-container current-pair-container">
                        <div class="pair-label" id="now-label"><b>NOW</b></div>
                        <div id="current-pair">
                            <div class="block secondary-block" id="current-secondary"></div>
                            <div class="block primary-block" id="current-primary"></div>
                        </div>
                    </div>
                    <div class="line"></div>

                    <div class="pair-container next-pair-container"> 
                        <div class="pair-label" id="next-label">Next</div>
                        <div id="next-pair">
                            <div class="block secondary-block" id="next-secondary"></div>
                            <div class="block primary-block" id="next-primary"></div>
							<div class="next-next-pair-container"> 
                            <div id="next-next-pair">
                                <div class="block secondary-block" id="next-next-secondary"></div>
                                <div class="block primary-block" id="next-next-primary"></div>
                            </div>
                        </div>
                        </div>
                        
                    </div>
                    <button id="save-pair-btn" style="display: none;">
                        <span class="save-btn-text" id="save-btn-text-label">Save</span>
                        <div class="save-btn-blocks-container">
                            <div id="saved-secondary-preview" class="block"></div>
                            <div id="saved-primary-preview" class="block"></div>
                        </div>
                    </button>
                    <button id="end-game-btn">End Game</button>
                </div>
                <div id="playfield-container">
                    <div id="playfield">
                        </div>
                </div>
            </div>
        </div>
		
		<div id="confirm-end-game-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <h2 id="confirm-end-game-title">Confirm</h2>
                <button id="confirm-end-game-yes-btn" class="confirm-btn-yes">Yes</button>
                <button id="confirm-end-game-no-btn" class="confirm-btn-no">No</button>
            </div>
        </div>

        <div id="game-over-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <h2 id="game-over-title">Game Over</h2>
                <p id="final-score-line"><span class="label">Your Final Score: </span><span id="final-score">0</span></p>
                <p id="highscore-message-line" style="display: none;">High Score: <span id="final-highscore">0</span></p>
                <p id="max-combo-line"><span class="label">Max Combo: </span><span id="max-combo">0</span></p><br>
                <button id="main-menu-btn">Main Menu</button>
            </div>
        </div>
    </div>
    <script>
document.addEventListener('DOMContentLoaded', () => {
    // Game Elements
    const modeSelectionModal = document.getElementById('mode-selection-modal');
    const gameInterface = document.getElementById('game-interface');
    const gameOverModal = document.getElementById('game-over-modal');
    const howToPlayModal = document.getElementById('how-to-play-modal');
    const confirmEndGameModal = document.getElementById('confirm-end-game-modal');

    const relaxModeBtn = document.getElementById('relax-mode-btn');
    const timedModeBtn = document.getElementById('timed-mode-btn');
    const pressureModeBtn = document.getElementById('pressure-mode-btn');
    const howToPlayBtn = document.getElementById('how-to-play-btn');
    const closeHowToPlayBtn = document.getElementById('close-how-to-play-btn');
    const mainmenuBtn = document.getElementById('main-menu-btn');
    const endgameBtn = document.getElementById('end-game-btn');
    const confirmEndGameYesBtn = document.getElementById('confirm-end-game-yes-btn');
    const confirmEndGameNoBtn = document.getElementById('confirm-end-game-no-btn');

    const scoreDisplay = document.getElementById('score');
    const highscoreDisplay = document.getElementById('highscore');
    const timerAreaContainer = document.getElementById('timer-area-container');
    const timeLeftDisplay = document.getElementById('time-left');
    const timeBar = document.getElementById('time-bar');

    const currentPrimaryDisplay = document.getElementById('current-primary');
    const currentSecondaryDisplay = document.getElementById('current-secondary');
    const nextPrimaryDisplay = document.getElementById('next-primary');
    const nextSecondaryDisplay = document.getElementById('next-secondary');
    const nextNextPrimaryDisplay = document.getElementById('next-next-primary');
    const nextNextSecondaryDisplay = document.getElementById('next-next-secondary');
    
	const savePairBtn = document.getElementById('save-pair-btn');
    const savedPrimaryDisplay = document.getElementById('saved-primary-preview');
    const savedSecondaryDisplay = document.getElementById('saved-secondary-preview');

    const playfieldElement = document.getElementById('playfield');
    const playfieldContainer = document.getElementById('playfield-container');
    const finalScoreDisplay = document.getElementById('final-score');
    const finalScoreLine = document.getElementById('final-score-line');
    const maxcomboDisplay = document.getElementById('max-combo');
    const maxcomboLine = document.getElementById('max-combo-line');
    const highscoreMessageLine = document.getElementById('highscore-message-line');
    const finalHighscoreDisplay = document.getElementById('final-highscore');

    // Language Elements
    const languageSelector = document.getElementById('language-selector');
    const languageLabel = document.getElementById('language-label');
    const pageTitleElement = document.getElementById('page-title');

    const mainMenuTitle = document.getElementById('main-menu-title');
    const htpTitle = document.getElementById('htp-title');
    const htpObjectiveLabelStrong = document.getElementById('htp-objective-label-strong');
    const htpObjectiveText = document.getElementById('htp-objective-text');
    const htpGameplayLabel = document.getElementById('htp-gameplay-label');
    const htpGameplayRule1 = document.getElementById('htp-gameplay-rule1');
    const htpGameplayRule2 = document.getElementById('htp-gameplay-rule2');
    const htpGameplayRule3 = document.getElementById('htp-gameplay-rule3');
    const htpGameplayRule4 = document.getElementById('htp-gameplay-rule4');
    const htpGameplayRule5 = document.getElementById('htp-gameplay-rule5');
    const htpGameplayRule6 = document.getElementById('htp-gameplay-rule6');
    const htpGameplayRule7 = document.getElementById('htp-gameplay-rule7');
    const htpGameplayRule8 = document.getElementById('htp-gameplay-rule8');
    const htpGameModesLabel = document.getElementById('htp-gamemodes-label');
    const htpRelaxModeLabel = document.getElementById('htp-relaxmode-label');
    const htpRelaxModeDesc = document.getElementById('htp-relaxmode-desc');
    const htpTimedModeLabel = document.getElementById('htp-timedmode-label');
    const htpTimedModeDesc = document.getElementById('htp-timedmode-desc');
    const htpPressureModeLabel = document.getElementById('htp-pressuremode-label');
    const htpPressureModeDesc = document.getElementById('htp-pressuremode-desc');
    const nowLabel = document.getElementById('now-label');
    const nextLabel = document.getElementById('next-label');
    const saveBtnTextLabel = document.getElementById('save-btn-text-label');
    const gameOverTitle = document.getElementById('game-over-title');
    const confirmEndGameTitle = document.getElementById('confirm-end-game-title');


    // Game Constants
    const ROWS = 12;
    const COLS = 6;
    const COLORS = ['green', 'blue', 'red', 'purple', 'orange'];
    const BLOCKS_PER_COLOR_IN_BAG = 20;
    const FALL_SPEED = 50; // ms per row
    const TIMED_MODE_DURATION = 100 * 1000;
    const PRESSURE_MODE_INITIAL_TIME = 10 * 1000;
    const PRESSURE_MODE_DECREMENT = 100;
    const PRESSURE_MODE_MIN_TIME = 500;
	const PRESSURE_MODE_THRESHOLD_TIME = 2000;
    const GRID_PADDING = 2;
    const GRID_GAP = 2;


    // Game State Variables
    let gameMode = '';
    let score = 0;
    let currentHighScore = 0;
    let combo = 0;
    let maxcombo = 0;
    let playfield = [];
    let currentPair = { primary: null, secondary: null };
    let nextPair = { primary: null, secondary: null };
	let nextNextPair = { primary: null, secondary: null };
    let savedPair = { primary: null, secondary: null };
    let cellSize = 40;
    let allowInput = false;
    let isFalling = false;
    let gameTimerInterval = null;
    let pressureTimerInterval = null;
    let currentPressureTimeLimit = PRESSURE_MODE_INITIAL_TIME;
    let pressureTurnStartTime = 0;
    let remainingTimedModeTime = 0;

    let primaryBlockPreview = null;
    let secondaryBlockPreview = null;
    let startDragPos = null;
    let startCell = null;
    let currentLanguage = 'en';
    let blockBag = []; // New: For the block bag generator


    const translations = {
        en: {
            pageTitle: "Falling Tile Matching Game",
            mainMenuTitle: "Falling Tile Matching",
            relaxMode: "Relax Mode",
            timedMode: "Timed Mode",
            pressureMode: "Pressure Mode",
            howToPlay: "How to Play",
            languageSelectorLabel: "Language:",

            howToPlayTitle: "How to Play",
            htpObjectiveLabelStrong: "<strong>Objective:</strong>",
            htpObjectiveText: "Arrange pairs of blocks and score points by matching groups of 4 or more same-colored blocks!",
            htpGameplayLabel: "<strong>Gameplay:</strong>",
            htpGameplayRule1: "You'll see a pair of blocks (NOW pair) and the Next pair that will come after. The block with the '×' is the primary block.",
            htpGameplayRule2: "To place blocks, tap (click) on an empty cell in the playfield. This will be the position of the primary block.",
            htpGameplayRule3: "Drag your finger (mouse) away from the primary block (up, down, left, or right) to position the secondary block next to it.<br>Release to place the pair.",
            htpGameplayRule4: "The placed blocks will fall to the lowest available position in their columns.",
            htpGameplayRule5: "When 4 or more blocks of the same color are touching (not diagonally), they will form a group and clear, and you'll earn points.",
            htpGameplayRule6: "Clearing multiple groups and making chain reaction with one placement increases your combo for more points!",
            htpGameplayRule7: "Use the \"Save\" button to swap the current pair with a saved pair. If no pair is saved, the current pair will be stored.",
            htpGameplayRule8: "The game is over when there are no valid empty spots left to place a pair of blocks.",
            htpGameModesLabel: "<strong>Game Modes:</strong>",
            htpRelaxModeLabel: "<strong>Relax Mode:</strong>",
            htpRelaxModeDesc: "Play at your own pace. No timers!",
            htpTimedModeLabel: "<strong>Timed Mode:</strong>",
            htpTimedModeDesc: "Score as many points as you can before the 100-second timer runs out.",
            htpPressureModeLabel: "<strong>Pressure Mode:</strong>",
            htpPressureModeDesc: "You have a limited time to make each move. This time gets shorter with each successful placement!<br>If you run out of time, a pair will be placed for you at a random empty column.",
            gotIt: "Got it!",

            scoreLabelText: "Score: ",
            highscoreLabelText: "High Score: ",
            comboLabelText: "Combo ",
            timeLabelText: "Time: ",

            nowLabel: "<b>NOW</b>",
            nextLabel: "Next",
            saveLabelText: "Save",
            endGameLabel: "End Game",

            gameOverTitle: "Game Over",
            finalScoreLabelText: "Your Final Score: ",
            newHighScoreMsg: "New High Score!",
            highScoreMsgPrefix: "High Score: ",
            maxComboLabelText: "Max Combo: ",
            mainMenuLabel: "Main Menu",
			
            confirmEndGameTitle: "Confirm End Game?",
            confirmEndGameYes: "Yes, End Game",
            confirmEndGameNo: "No, Continue"
        },
        vi: {
            pageTitle: "Trò chơi xếp cặp khối rơi",
            mainMenuTitle: "Trò chơi Xếp cặp khối rơi",
            relaxMode: "Chế độ Thư giãn",
            timedMode: "Chế độ Tính giờ",
            pressureMode: "Chế độ Áp lực",
            howToPlay: "Hướng dẫn chơi",
            languageSelectorLabel: "Ngôn ngữ:",

            howToPlayTitle: "Hướng dẫn chơi",
            htpObjectiveLabelStrong: "<strong>Mục tiêu:</strong>",
            htpObjectiveText: "Xếp các cặp khối được cho và ghi điểm bằng cách ghép thành các nhóm từ 4 khối cùng màu trở lên!",
            htpGameplayLabel: "<strong>Cách chơi:</strong>",
            htpGameplayRule1: "Bạn sẽ thấy một cặp khối (cặp HIỆN TẠI) và cặp \"Kế tiếp\" sẽ xuất hiện sau đó. Khối có dấu '×' là khối chính.",
            htpGameplayRule2: "Để đặt khối, chạm (hoặc nhấp chuột) vào một ô trống trên bảng chơi. Đây sẽ là vị trí của khối chính.",
            htpGameplayRule3: "Kéo ngón tay (chuột) ra khỏi khối chính theo hướng lên, xuống, trái hoặc phải để định vị khối phụ bên cạnh nó. Thả ra để đặt cặp khối.",
            htpGameplayRule4: "Các khối đã đặt sẽ rơi xuống vị trí trống thấp nhất trong cột của chúng.",
            htpGameplayRule5: "Khi có 4 khối cùng màu trở lên ở sát nhau (không theo đường chéo), chúng tạo thành một nhóm và sẽ bị phá, bạn sẽ nhận được điểm.",
            htpGameplayRule6: "Phá nhiều nhóm, tạo ra phản ứng dây chuyền bằng một lần đặt để tăng chuỗi của bạn và tăng thêm nhiều điểm!",
            htpGameplayRule7: "Sử dụng nút \"Lưu trữ\" để đổi cặp hiện tại với một cặp đã lưu trữ. Nếu chưa có cặp nào được lưu, cặp hiện tại sẽ được lưu trữ.",
            htpGameplayRule8: "Trò chơi kết thúc khi không còn ô trống hợp lệ nào để đặt một cặp khối.",
            htpGameModesLabel: "<strong>Chế độ chơi:</strong>",
            htpRelaxModeLabel: "<strong>Chế độ Thư giãn:</strong>",
            htpRelaxModeDesc: "Chơi theo tốc độ của riêng bạn. Không giới hạn thời gian!",
            htpTimedModeLabel: "<strong>Chế độ Tính giờ:</strong>",
            htpTimedModeDesc: "Ghi càng nhiều điểm càng tốt trước khi hết 100 giây.",
            htpPressureModeLabel: "<strong>Chế độ Áp lực:</strong>",
            htpPressureModeDesc: "Bạn bị giới hạn thời gian thực hiện mỗi nước đi. Thời gian này sẽ ngắn dần sau mỗi lần đặt thành công!<br>Nếu hết giờ, một cặp khối sẽ được tự động đặt vào một cột trống ngẫu nhiên.",
            gotIt: "Đã hiểu!",

            scoreLabelText: "Điểm: ",
            highscoreLabelText: "Điểm cao: ",
            comboLabelText: "Chuỗi ",
            timeLabelText: "Thời gian: ",

            nowLabel: "<b>HIỆN TẠI</b>",
            nextLabel: "Kế tiếp",
            saveLabelText: "Lưu trữ",
            endGameLabel: "Kết thúc trò chơi",

            gameOverTitle: "Trò chơi kết thúc",
            finalScoreLabelText: "Điểm của bạn: ",
            newHighScoreMsg: "Đạt kỷ lục mới!",
            highScoreMsgPrefix: "Điểm cao: ",
            maxComboLabelText: "Chuỗi tối đa: ",
            mainMenuLabel: "Menu chính",
			
			confirmEndGameTitle: "Xác nhận Kết thúc trò chơi?",
            confirmEndGameYes: "Có, Kết thúc",
            confirmEndGameNo: "Không, Tiếp tục"
        }
    };

    function setLanguage(lang) {
        currentLanguage = lang;
        localStorage.setItem('gameLanguage', lang);
        languageSelector.value = lang;

        const t = translations[lang] || translations.en;

        pageTitleElement.textContent = t.pageTitle;
        mainMenuTitle.textContent = t.mainMenuTitle;
        relaxModeBtn.textContent = t.relaxMode;
        timedModeBtn.textContent = t.timedMode;
        pressureModeBtn.textContent = t.pressureMode;
        howToPlayBtn.textContent = t.howToPlay;
        languageLabel.textContent = t.languageSelectorLabel;

        htpTitle.textContent = t.howToPlayTitle;
        htpObjectiveLabelStrong.innerHTML = t.htpObjectiveLabelStrong;
        htpObjectiveText.innerHTML = t.htpObjectiveText;
        htpGameplayLabel.innerHTML = t.htpGameplayLabel;
        htpGameplayRule1.innerHTML = t.htpGameplayRule1;
        htpGameplayRule2.innerHTML = t.htpGameplayRule2;
        htpGameplayRule3.innerHTML = t.htpGameplayRule3;
        htpGameplayRule4.innerHTML = t.htpGameplayRule4;
        htpGameplayRule5.innerHTML = t.htpGameplayRule5;
        htpGameplayRule6.innerHTML = t.htpGameplayRule6;
        htpGameplayRule7.innerHTML = t.htpGameplayRule7;
        htpGameplayRule8.innerHTML = t.htpGameplayRule8;
        htpGameModesLabel.innerHTML = t.htpGameModesLabel;
        htpRelaxModeLabel.innerHTML = t.htpRelaxModeLabel;
        htpRelaxModeDesc.innerHTML = t.htpRelaxModeDesc;
        htpTimedModeLabel.innerHTML = t.htpTimedModeLabel;
        htpTimedModeDesc.innerHTML = t.htpTimedModeDesc;
        htpPressureModeLabel.innerHTML = t.htpPressureModeLabel;
        htpPressureModeDesc.innerHTML = t.htpPressureModeDesc;
        closeHowToPlayBtn.textContent = t.gotIt;

        document.querySelector('#score-area .label').textContent = t.scoreLabelText;
        document.querySelector('#highscore-area .label').textContent = t.highscoreLabelText;
        document.querySelector('#combo-area .label').textContent = t.comboLabelText;
        document.querySelector('#timer-area-container .label').textContent = t.timeLabelText;

        nowLabel.innerHTML = t.nowLabel;
        nextLabel.textContent = t.nextLabel;
        saveBtnTextLabel.textContent = t.saveLabelText;
        endgameBtn.textContent = t.endGameLabel;

        gameOverTitle.textContent = t.gameOverTitle;
        document.querySelector('#final-score-line .label').textContent = t.finalScoreLabelText;
        document.querySelector('#max-combo-line .label').textContent = t.maxComboLabelText;
        mainmenuBtn.textContent = t.mainMenuLabel;
		
		confirmEndGameTitle.textContent = t.confirmEndGameTitle;
        confirmEndGameYesBtn.textContent = t.confirmEndGameYes;
        confirmEndGameNoBtn.textContent = t.confirmEndGameNo;

        updateComboDisplay();
    }

    function loadLanguage() {
        const savedLang = localStorage.getItem('gameLanguage');
        if (savedLang && translations[savedLang]) {
            setLanguage(savedLang);
        } else {
            setLanguage('en');
        }
    }

    languageSelector.addEventListener('change', (event) => {
        setLanguage(event.target.value);
    });


    function getHighScore(mode) {
        return parseInt(localStorage.getItem(`highscore_${mode}`) || '0', 10);
    }

    function setHighScore(mode, newScore) {
        localStorage.setItem(`highscore_${mode}`, newScore.toString());
    }

    // --- New Block Bag Generator Logic ---
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function generateBlockBag() {
        console.log("Generating new block bag...");
        let tempBag = [];
        let attempts = 0;
        const MAX_ATTEMPTS = 100; // To prevent infinite loops

        while (attempts < MAX_ATTEMPTS) {
            attempts++;
            tempBag = [];
            for (const color of COLORS) {
                for (let i = 0; i < BLOCKS_PER_COLOR_IN_BAG; i++) {
                    tempBag.push(color);
                }
            }
            shuffleArray(tempBag);

            if (isValidBag(tempBag)) {
                blockBag = tempBag;
                console.log("Valid bag generated:", blockBag.slice(0,12)); // Log first 12 for brevity
                return;
            }
        }
        console.warn("Failed to generate a valid bag after MAX_ATTEMPTS. Using last shuffled bag (may not meet all criteria).");
        blockBag = tempBag; // Use the last shuffled bag if criteria not met after many attempts
    }

    function isValidBag(bag) {
        if (bag.length < 8) return true; // Not enough pairs to check all conditions

        // Condition 1: No three identical color pairs (including reversed) in a range of 8 blocks (4 pairs)
        for (let i = 0; i <= bag.length - 8; i += 2) { // Check 4 pairs (8 blocks) at a time
            const pairsInRange = [];
            for (let j = 0; j < 4; j++) {
                if (i + (j*2) + 1 < bag.length) {
                    pairsInRange.push([bag[i + (j*2)], bag[i + (j*2) + 1]]);
                }
            }

            const pairCounts = {};
            for (const pair of pairsInRange) {
                const p1 = pair[0];
                const p2 = pair[1];
                // Normalize pair to count (e.g., [red, blue] is same as [blue, red])
                const key = p1 <= p2 ? `${p1}-${p2}` : `${p2}-${p1}`;
                pairCounts[key] = (pairCounts[key] || 0) + 1;
                if (pairCounts[key] >= 3) {
                    console.log("Validation fail: 3 identical pairs in range of 8 blocks.", pairsInRange, pairCounts);
                    return false; // Found three identical pairs
                }
            }
        }


        // Condition 2: First two pairs in the bag are restricted to three different colors
        if (bag.length >= 4) {
            const firstTwoPairsColors = new Set();
            firstTwoPairsColors.add(bag[0]);
            firstTwoPairsColors.add(bag[1]);
            firstTwoPairsColors.add(bag[2]);
            firstTwoPairsColors.add(bag[3]);
            if (firstTwoPairsColors.size > 3) {
                console.log("Validation fail: First two pairs have more than 3 unique colors.", Array.from(firstTwoPairsColors));
                return false;
            }
        }


        // Condition 3: First four pairs in the bag are restricted to four different colors
        if (bag.length >= 8) {
            const firstFourPairsColors = new Set();
            for (let i = 0; i < 8; i++) { // First 4 pairs = 8 blocks
                if (i < bag.length) firstFourPairsColors.add(bag[i]);
            }
            if (firstFourPairsColors.size > 4) {
                 console.log("Validation fail: First four pairs have more than 4 unique colors.", Array.from(firstFourPairsColors));
                return false;
            }
        }
        return true;
    }


    function initGame() {
        modeSelectionModal.style.display = 'none';
        gameOverModal.style.display = 'none';
        howToPlayModal.style.display = 'none';
        confirmEndGameModal.style.display = 'none';
        gameInterface.style.display = 'flex';
        savePairBtn.style.display = 'flex';

        finalScoreLine.style.display = 'block';
        highscoreMessageLine.style.display = 'none';
        maxcomboLine.style.display = 'none';

        if (gameMode === 'timed') {
            timerAreaContainer.style.display = 'flex';
            allowInput = true;
            startTimedModeTimer();
        } else if (gameMode === 'pressure') {
            timerAreaContainer.style.display = 'flex';
            allowInput = true;
            startPressureTurnTimer();
        } else {
            timerAreaContainer.style.display = 'none';
            allowInput = true;
        }
	    playfieldContainer.style.marginBottom = '15px';
		playfieldContainer.style.marginRight = '4px';

        score = 0;
        combo = 0;
        maxcombo = 0;
        currentHighScore = getHighScore(gameMode);
        updateScoreDisplay();
        highscoreDisplay.textContent = currentHighScore;
        updateComboDisplay();
        clearPlayfield();
        generatePlayfieldCells();
		savedPair = { primary: null, secondary: null };
        adjustCellSize();

        blockBag = []; // Clear bag before new game
        generateBlockBag(); // Generate initial bag

        // Initialize currentPair, nextPair, and nextNextPair from the bag
        if (blockBag.length >= 2) {
            currentPair.primary = blockBag.shift();
            currentPair.secondary = blockBag.shift();
        } else {
            console.error("Block bag too short for initial currentPair, using random.");
            currentPair.primary = getRandomColorFallback();
            currentPair.secondary = getRandomColorFallback();
        }

        if (blockBag.length >= 2) {
            nextPair.primary = blockBag.shift();
            nextPair.secondary = blockBag.shift();
        } else {
            console.error("Block bag too short for initial nextPair, using random.");
            nextPair.primary = getRandomColorFallback();
            nextPair.secondary = getRandomColorFallback();
        }

        if (blockBag.length >= 2) { // New: Initialize nextNextPair
            nextNextPair.primary = blockBag.shift();
            nextNextPair.secondary = blockBag.shift();
        } else {
            console.error("Block bag too short for initial nextNextPair, using random.");
            nextNextPair.primary = getRandomColorFallback();
            nextNextPair.secondary = getRandomColorFallback();
        }

        updatePreviewDisplays(); // This will now also call updateNextNextPreviewDisplay internally or separately

        allowInput = true;
        isFalling = false;

        console.log("Game initialized in mode:", gameMode, ", High Score:", currentHighScore, "Lang:", currentLanguage);
    }

    function updateSavedPairDisplay() {
        const nextPairBlockSize = Math.max(15, Math.floor(cellSize * 0.85));

        if (!savedPrimaryDisplay || !savedSecondaryDisplay) return;

        const basePrimaryClass = 'block primary-block';
        const baseSecondaryClass = 'block secondary-block';
        const emptySlotColor = '#bdbdbd';

        if (savedPair && savedPair.primary) {
            savedPrimaryDisplay.className = `${basePrimaryClass} ${savedPair.primary}`;
            savedSecondaryDisplay.className = `${baseSecondaryClass} ${savedPair.secondary}`;
            savedPrimaryDisplay.style.backgroundColor = '';
            savedSecondaryDisplay.style.backgroundColor = '';
        } else {
            savedPrimaryDisplay.className = basePrimaryClass;
            savedSecondaryDisplay.className = baseSecondaryClass;
            savedPrimaryDisplay.style.backgroundColor = emptySlotColor;
            savedSecondaryDisplay.style.backgroundColor = emptySlotColor;
        }

        [savedPrimaryDisplay, savedSecondaryDisplay].forEach(b => {
            b.style.width = `${nextPairBlockSize}px`;
            b.style.height = `${nextPairBlockSize}px`;
            b.style.borderRadius = `${Math.floor(nextPairBlockSize * 0.2)}px`;
        });
    }


    function adjustCellSize() {
        const playfieldPaddingAndGapsHorizontal = 4 + (COLS - 1) * 2;
        const playfieldPaddingAndGapsVertical = 4 + (ROWS - 1) * 2;

        const gameDisplayAreaWidth = document.getElementById('game-display-area').offsetWidth;
        const previewAreaWidth = document.getElementById('pairs-preview-area').offsetWidth;
        playfieldContainer.style.width = `calc(${gameDisplayAreaWidth}px - ${previewAreaWidth}px)`;


        const availableWidthForPlayfield = playfieldContainer.offsetWidth - playfieldPaddingAndGapsHorizontal;
        const availableHeightForPlayfield = playfieldContainer.offsetHeight - playfieldPaddingAndGapsVertical;

        const cellSizeBasedOnWidth = Math.floor(availableWidthForPlayfield / COLS);
        const cellSizeBasedOnHeight = Math.floor(availableHeightForPlayfield / ROWS);

        cellSize = Math.max(10, Math.min(cellSizeBasedOnWidth, cellSizeBasedOnHeight));

        document.documentElement.style.setProperty('--cell-size', `${cellSize}px`);

        const nextPairBlockSize = Math.max(15, Math.floor(cellSize * 0.85));
        const currentPairBlockSize = Math.max(18, Math.floor(nextPairBlockSize * 1.25));

        document.querySelectorAll('#current-pair .block').forEach(b => {
            b.style.width = `${currentPairBlockSize}px`;
            b.style.height = `${currentPairBlockSize}px`;
            b.style.borderRadius = `${Math.floor(currentPairBlockSize * 0.2)}px`;
        });
        document.querySelectorAll('#next-pair .block, #next-next-pair .block').forEach(b => { // Added #next-next-pair .block
            b.style.width = `${nextPairBlockSize}px`;
            b.style.height = `${nextPairBlockSize}px`;
            b.style.borderRadius = `${Math.floor(nextPairBlockSize * 0.2)}px`;
        });

        updateSavedPairDisplay();

        playfieldElement.style.width = `${COLS * cellSize + (COLS - 1) * 2}px`;
        playfieldElement.style.height = `${ROWS * cellSize + (ROWS - 1) * 2}px`;

        renderPlayfield();
    }


    window.addEventListener('resize', adjustCellSize);


    function clearPlayfield() {
        playfield = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
        playfieldElement.innerHTML = '';
    }

    function generatePlayfieldCells() {
        playfieldElement.innerHTML = '';
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.createElement('div');
                cell.classList.add('playfield-cell');
                cell.dataset.row = r;
                cell.dataset.col = c;
                playfieldElement.appendChild(cell);
            }
        }
    }

    // Fallback random color function if bag generation fails critically
    function getRandomColorFallback() {
        return COLORS[Math.floor(Math.random() * COLORS.length)];
    }

    function generateNewPair() {
        currentPair = { ...nextPair };
        nextPair = { ...nextNextPair }; // nextNext becomes next

        if (blockBag.length < 2) {
            console.log("Block bag empty or near empty for nextNextPair, regenerating...");
            generateBlockBag();
        }

        if (blockBag.length >= 2) {
            nextNextPair.primary = blockBag.shift(); // Get new nextNext primary
            nextNextPair.secondary = blockBag.shift(); // Get new nextNext secondary
        } else {
            console.error("Block bag is critically low after attempted regeneration for nextNextPair. Using fallback.");
            nextNextPair.primary = getRandomColorFallback();
            nextNextPair.secondary = getRandomColorFallback();
        }

        // Fallback for currentPair if it was somehow not set (e.g., initial empty nextNextPair)
        if (!currentPair.primary) {
            console.warn("Current pair was not properly set from nextPair, pulling from bag/fallback.");
            if (blockBag.length >= 2) {
                currentPair.primary = blockBag.shift();
                currentPair.secondary = blockBag.shift();
            } else {
                currentPair.primary = getRandomColorFallback();
                currentPair.secondary = getRandomColorFallback();
            }
        }
        // Fallback for nextPair if it was somehow not set
        if (!nextPair.primary) {
             console.warn("Next pair was not properly set from nextNextPair, pulling from bag/fallback.");
            if (blockBag.length >= 2) {
                nextPair.primary = blockBag.shift();
                nextPair.secondary = blockBag.shift();
            } else {
                nextPair.primary = getRandomColorFallback();
                nextPair.secondary = getRandomColorFallback();
            }
        }

        updatePreviewDisplays();
    }


    function updatePreviewDisplays() {
        if (currentPair.primary) {
            currentPrimaryDisplay.className = `block primary-block ${currentPair.primary}`;
            currentSecondaryDisplay.className = `block secondary-block ${currentPair.secondary}`;
        }
        if (nextPair.primary) {
            nextPrimaryDisplay.className = `block primary-block ${nextPair.primary}`;
            nextSecondaryDisplay.className = `block secondary-block ${nextPair.secondary}`;
        }
		
        if (nextNextPair.primary && nextNextPrimaryDisplay && nextNextSecondaryDisplay) {
            nextNextPrimaryDisplay.className = `block primary-block ${nextNextPair.primary}`;
            nextNextSecondaryDisplay.className = `block secondary-block ${nextNextPair.secondary}`;
        } else if (nextNextPrimaryDisplay && nextNextSecondaryDisplay) {
            // Handle case where nextNextPair might be temporarily empty or elements not found
            nextNextPrimaryDisplay.className = `block primary-block`; // Clear class
            nextNextSecondaryDisplay.className = `block secondary-block`; // Clear class
        }
    }

    playfieldElement.addEventListener('mousedown', handleDragStart);
    playfieldElement.addEventListener('touchstart', handleDragStart, { passive: false });

    function handleDragStart(e) {
    if (!allowInput || isFalling) return;
    e.preventDefault();

    const rect = playfieldElement.getBoundingClientRect();
    const clientX = e.clientX || e.touches[0].clientX;
    const clientY = e.clientY || e.touches[0].clientY;

    const x = clientX - rect.left;
    const y = clientY - rect.top;

    const effectiveX = x - GRID_PADDING;
    const effectiveY = y - GRID_PADDING;

    let clickCol = -1;
    let clickRow = -1;

    for (let c = 0; c < COLS; c++) {
        const cellStartPos = c * (cellSize + GRID_GAP);
        const cellEndPos = cellStartPos + cellSize;
        if (effectiveX >= cellStartPos && effectiveX < cellEndPos) {
            clickCol = c;
            break;
        }
    }

    for (let r = 0; r < ROWS; r++) {
        const cellStartPos = r * (cellSize + GRID_GAP);
        const cellEndPos = cellStartPos + cellSize;
        if (effectiveY >= cellStartPos && effectiveY < cellEndPos) {
            clickRow = r;
            break;
        }
    }

    if (isValidCell(clickRow, clickCol) && !playfield[clickRow][clickCol]) {
        startCell = { row: clickRow, col: clickCol };
        startDragPos = { x: clientX, y: clientY };

        removePlacementPreview();
        primaryBlockPreview = createVisualBlock(currentPair.primary, startCell.row, startCell.col, true);
        primaryBlockPreview.classList.add('preview-block');
        playfieldElement.appendChild(primaryBlockPreview);

        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchend', handleDragEnd);
    } else {
        startCell = null;
        startDragPos = null;
    }
}

    function handleDragMove(e) {
        if (!startCell) return;
        e.preventDefault();

        const clientX = e.clientX || e.touches[0].clientX;
        const clientY = e.clientY || e.touches[0].clientY;

        const deltaX = clientX - startDragPos.x;
        const deltaY = clientY - startDragPos.y;

        removeSecondaryBlockPreview();

        let secondaryPos = { ...startCell };
        let direction = '';

        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > cellSize / 3) {
                secondaryPos.col = startCell.col + 1;
                direction = 'right';
            } else if (deltaX < -cellSize / 3) {
                secondaryPos.col = startCell.col - 1;
                direction = 'left';
            }
        } else {
            if (deltaY > cellSize / 3) {
                secondaryPos.row = startCell.row + 1;
                direction = 'down';
            } else if (deltaY < -cellSize / 3) {
                secondaryPos.row = startCell.row - 1;
                direction = 'up';
            }
        }

        if (direction && (secondaryPos.row !== startCell.row || secondaryPos.col !== startCell.col)) {
             if (isValidCell(secondaryPos.row, secondaryPos.col)) {
                secondaryBlockPreview = createVisualBlock(currentPair.secondary, secondaryPos.row, secondaryPos.col, false);
                secondaryBlockPreview.classList.add('preview-block');
                playfieldElement.appendChild(secondaryBlockPreview);
            }
        }
    }


async function handleDragEnd(e) {
    if (!startCell) return;

    document.removeEventListener('mousemove', handleDragMove);
    document.removeEventListener('touchmove', handleDragMove);
    document.removeEventListener('mouseup', handleDragEnd);
    document.removeEventListener('touchend', handleDragEnd);

    const clientX = e.clientX || e.changedTouches[0].clientX;
    const clientY = e.clientY || e.changedTouches[0].clientY;

    const deltaX = clientX - startDragPos.x;
    const deltaY = clientY - startDragPos.y;

    let primaryTarget = { ...startCell };
    let secondaryTarget = { ...startCell };

    let placementValid = false;

    if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > cellSize / 2) secondaryTarget.col++;
        else if (deltaX < -cellSize / 2) secondaryTarget.col--;
    } else {
        if (deltaY > cellSize / 2) secondaryTarget.row++;
        else if (deltaY < -cellSize / 2) secondaryTarget.row--;
    }

    if (secondaryTarget.row === primaryTarget.row && secondaryTarget.col === primaryTarget.col) {
        removePlacementPreview();
        startCell = null;
        startDragPos = null;
        return;
    }

    if (isValidCell(primaryTarget.row, primaryTarget.col) && !playfield[primaryTarget.row][primaryTarget.col] &&
        isValidCell(secondaryTarget.row, secondaryTarget.col) && !playfield[secondaryTarget.row][secondaryTarget.col]) {
        placementValid = true;
    }

    removePlacementPreview();

    if (placementValid) {
        allowInput = false;
        combo = 0;
        updateComboDisplay();

        let pBlockData = {
            finalRow: primaryTarget.row,
            finalCol: primaryTarget.col,
            color: currentPair.primary,
            isPrimary: true,
            id: Date.now() + '_p'
        };
        let sBlockData = {
            finalRow: secondaryTarget.row,
            finalCol: secondaryTarget.col,
            color: currentPair.secondary,
            isPrimary: false,
            id: Date.now() + '_s'
        };
        const animateBlockFall = async (blockInfo) => {
            const targetTopPosition = GRID_PADDING + (blockInfo.finalRow * cellSize) + (blockInfo.finalRow * GRID_GAP);
            const targetLeftPosition = GRID_PADDING + (blockInfo.finalCol * cellSize) + (blockInfo.finalCol * GRID_GAP);
            const visualBlock = createVisualBlock(blockInfo.color, blockInfo.finalRow, blockInfo.finalCol, blockInfo.isPrimary, blockInfo.id);
            visualBlock.style.top = `${targetTopPosition}px`;
            visualBlock.style.left = `${targetLeftPosition}px`;
            visualBlock.style.opacity = '1';
            playfieldElement.appendChild(visualBlock);
            void visualBlock.offsetWidth;
            return visualBlock;
        };

        playfield[pBlockData.finalRow][pBlockData.finalCol] = { color: pBlockData.color, isPrimary: pBlockData.isPrimary, id: pBlockData.id };
        playfield[sBlockData.finalRow][sBlockData.finalCol] = { color: sBlockData.color, isPrimary: sBlockData.isPrimary, id: sBlockData.id };

        await Promise.all([
            animateBlockFall(pBlockData),
            animateBlockFall(sBlockData)
        ]);

        if (gameMode === 'pressure') {
            clearTimeout(pressureTimerInterval);
             currentPressureTimeLimit = currentPressureTimeLimit > PRESSURE_MODE_THRESHOLD_TIME ? currentPressureTimeLimit - PRESSURE_MODE_DECREMENT : Math.max(PRESSURE_MODE_MIN_TIME, currentPressureTimeLimit - Math.trunc(PRESSURE_MODE_DECREMENT/10));
			//console.log(currentPressureTimeLimit);
        }

        generateNewPair(); // Generate new pair AFTER current one is used
        await handleGravityAndMatches();
    }

    startCell = null;
    startDragPos = null;
}

    function removePlacementPreview() {
        if (primaryBlockPreview) primaryBlockPreview.remove();
        removeSecondaryBlockPreview();
        primaryBlockPreview = null;
    }
    function removeSecondaryBlockPreview() {
        if (secondaryBlockPreview) secondaryBlockPreview.remove();
        secondaryBlockPreview = null;
    }


    function isValidCell(row, col) {
        return row >= 0 && row < ROWS && col >= 0 && col < COLS;
    }

 function createVisualBlock(color, row, col, isPrimary, id = null) {
    const blockElement = document.createElement('div');
    blockElement.classList.add('block', 'playfield-block', color);
    if (isPrimary) blockElement.classList.add('primary-block');
    blockElement.style.width = `${cellSize}px`;
    blockElement.style.height = `${cellSize}px`;
    blockElement.style.left = `${GRID_PADDING + (col * cellSize) + (col * GRID_GAP)}px`;
    blockElement.style.top = `${GRID_PADDING + (row * cellSize) + (row * GRID_GAP)}px`;
    blockElement.style.borderRadius = `${Math.floor(cellSize * 0.2)}px`;
    if (id) blockElement.dataset.id = id;
    return blockElement;
}

    function renderPlayfield() {
        playfieldElement.querySelectorAll('.playfield-block').forEach(b => b.remove());

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (playfield[r][c]) {
                    const blockData = playfield[r][c];
                    const visualBlock = createVisualBlock(blockData.color, r, c, blockData.isPrimary, blockData.id);
                    playfieldElement.appendChild(visualBlock);
                }
            }
        }
    }


    async function handleGravityAndMatches() {
        isFalling = true;
        allowInput = false;
        let fell;
        do {
            fell = await applyGravity();
            if (fell) await new Promise(resolve => setTimeout(resolve, FALL_SPEED * 1.5));
        } while (fell);

        let matchesFound;
        do {
            matchesFound = await findAndClearMatches();
            if (matchesFound > 0) {
                combo = combo === 0 ? 1 : combo + 1;
		        maxcombo = Math.max(maxcombo, combo);
		        if (combo < 4) score += matchesFound * Math.pow(2,combo-1);
		        else score += matchesFound * 8 * (combo-3);
                updateScoreDisplay();
                updateComboDisplay();
                do {
                    fell = await applyGravity();
                    if (fell) await new Promise(resolve => setTimeout(resolve, FALL_SPEED * 1.5));
                } while (fell);
            }
        } while (matchesFound > 0);

        isFalling = false;
        if (isGameOver()) {
            handleGameOver();
        } else {
            allowInput = true;
            if (gameMode === 'pressure') {
                startPressureTurnTimer();
            }
        }
    }


async function applyGravity() {
    let blocksFell = false;
    let maxFallDistanceInPass = 0;

    for (let c = 0; c < COLS; c++) {
        for (let r = ROWS - 2; r >= 0; r--) {
            if (playfield[r][c] && !playfield[r + 1][c]) {
                let fallDistance = 0;
                for (let lookRow = r + 1; lookRow < ROWS; lookRow++) {
                    if (!playfield[lookRow][c]) {
                        fallDistance++;
                    } else {
                        break;
                    }
                }

                if (fallDistance > 0) {
                    const blockData = playfield[r][c];
                    playfield[r + fallDistance][c] = blockData;
                    playfield[r][c] = null;
                    blocksFell = true;
                    maxFallDistanceInPass = Math.max(maxFallDistanceInPass, fallDistance);

                    const visualBlock = playfieldElement.querySelector(`.playfield-block[data-id="${blockData.id}"]`);
                    if (visualBlock) {
                        const newTop = GRID_PADDING + (r + fallDistance) * cellSize + (r + fallDistance) * GRID_GAP;
                        const fallDuration = fallDistance * (FALL_SPEED / 1000);
                        const currentTransitions = visualBlock.style.transition.split(',').map(t => t.trim()).filter(t => t !== '');
                        const otherTransitions = currentTransitions.filter(t => !t.startsWith('top'));
                        visualBlock.style.transition = `top ${fallDuration.toFixed(3)}s linear${otherTransitions.length > 0 ? ', ' + otherTransitions.join(', ') : ''}`;
                        visualBlock.style.top = `${newTop}px`;
                    }
                }
            }
        }
    }

    if (blocksFell) {
        const waitDuration = maxFallDistanceInPass * FALL_SPEED + 50;
        await new Promise(resolve => setTimeout(resolve, waitDuration));
    }
    return blocksFell;
}


async function findAndClearMatches() {
    const toClearSet = new Set();
    const visited = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));

    function getNeighbors(r, c) {
        const neighbors = [];
        if (r > 0) neighbors.push({ r: r - 1, c });
        if (r < ROWS - 1) neighbors.push({ r: r + 1, c });
        if (c > 0) neighbors.push({ r, c: c - 1 });
        if (c < COLS - 1) neighbors.push({ r, c: c + 1 });
        return neighbors;
    }

    function searchN(r, c, color, currentGroup) {
        if (!isValidCell(r, c) ||
            visited[r][c] ||
            !playfield[r][c] ||
            playfield[r][c].color !== color
           ) {
            return;
        }
        visited[r][c] = true;
        currentGroup.add(`${r}-${c}`);
        const neighbors = getNeighbors(r, c);
        for (const neighbor of neighbors) {
            searchN(neighbor.r, neighbor.c, color, currentGroup);
        }
    }

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (playfield[r][c] && !visited[r][c]) {
                const currentGroup = new Set();
                searchN(r, c, playfield[r][c].color, currentGroup);
                if (currentGroup.size >= 4) {
                    currentGroup.forEach(cellString => toClearSet.add(cellString));
                }
            }
        }
    }

    if (toClearSet.size > 0) {
        const clearPromises = [];
        toClearSet.forEach(cellString => {
            const [r_str, c_str] = cellString.split('-');
            const r = parseInt(r_str, 10);
            const c = parseInt(c_str, 10);

            if (playfield[r][c] && playfield[r][c].id) {
                const visualBlock = playfieldElement.querySelector(`.playfield-block[data-id="${playfield[r][c].id}"]`);
                if (visualBlock && !visualBlock.classList.contains('clearing')) {
                    visualBlock.classList.add('clearing');
                    clearPromises.push(new Promise(resolve => {
                        visualBlock.addEventListener('animationend', () => {
                            visualBlock.remove();
                            resolve();
                        }, { once: true });
                    }));
                }
            }
        });
        await Promise.all(clearPromises);
        toClearSet.forEach(cellString => {
            const [r_str, c_str] = cellString.split('-');
            const r = parseInt(r_str, 10);
            const c = parseInt(c_str, 10);
            if (playfield[r] && playfield[r][c]) {
                 playfield[r][c] = null;
            }
        });
        return toClearSet.size;
    }
    return 0;
}


    function startTimedModeTimer() {
        remainingTimedModeTime = TIMED_MODE_DURATION;
        updateTimerDisplay(remainingTimedModeTime);
        if (gameTimerInterval) clearInterval(gameTimerInterval);
        gameTimerInterval = setInterval(() => {
            if (gameMode !== 'timed') {
                clearInterval(gameTimerInterval);
                return;
            }
            if (!allowInput) {
                return;
            }
            remainingTimedModeTime -= 100;
            if (remainingTimedModeTime <= 0) {
                remainingTimedModeTime = 0;
                clearInterval(gameTimerInterval);
                updateTimerDisplay(remainingTimedModeTime);
                handleGameOver();
            } else {
                updateTimerDisplay(remainingTimedModeTime);
            }
        }, 100);
    }

    function startPressureTurnTimer() {
        pressureTurnStartTime = Date.now();
        updateTimerDisplay(currentPressureTimeLimit);
		if (!allowInput) return;
        if (pressureTimerInterval) clearTimeout(pressureTimerInterval);
        pressureTimerInterval = setTimeout(() => {
            //if (!allowInput) return;
            autoPlacePressureBlock();
        }, currentPressureTimeLimit);

        function updatePressureBar() {
            if (!allowInput && gameMode === 'pressure') {
                 requestAnimationFrame(updatePressureBar);
                 return;
            }
            const elapsedTime = Date.now() - pressureTurnStartTime;
            const remainingTime = currentPressureTimeLimit - elapsedTime;
            if (remainingTime <=0 && allowInput) {
                updateTimerDisplay(0);
                return;
            }
            if (gameMode === 'pressure' && allowInput) {
                 updateTimerDisplay(Math.max(0, remainingTime));
                 requestAnimationFrame(updatePressureBar);
            }
        }
        requestAnimationFrame(updatePressureBar);
    }


    function updateTimerDisplay(ms) {
        const seconds = (ms / 1000).toFixed(1);
        timeLeftDisplay.textContent = `${seconds}`;
        let percentage = 100;
        if (gameMode === 'timed') {
            percentage = (ms / TIMED_MODE_DURATION) * 100;
        } else if (gameMode === 'pressure') {
            percentage = (ms / currentPressureTimeLimit) * 100;
            if (!allowInput && ms > 0) {
                percentage = 100;
            }
        }
        timeBar.style.width = `${Math.max(0, percentage)}%`;
        if (percentage < 25) timeBar.style.backgroundColor = '#F44336';
        else if (percentage < 50) timeBar.style.backgroundColor = '#FF9800';
        else timeBar.style.backgroundColor = '#4CAF50';
    }

    async function autoPlacePressureBlock() {
        console.log("Pressure mode timeout! Attempting auto-placement.");
        allowInput = false;
        removePlacementPreview();

        const availableColumns = [];
        for (let c = 0; c < COLS; c++) {
            if (isValidCell(0, c) && !playfield[0][c] && isValidCell(1, c) && !playfield[1][c]) {
                availableColumns.push(c);
            }
        }

        if (availableColumns.length === 0) {
            console.log("No available columns for auto-placement. Game over.");
            handleGameOver();
            return;
        }

        const randomColumnIndex = Math.floor(Math.random() * availableColumns.length);
        const chosenCol = availableColumns[randomColumnIndex];
        const secondaryRow = 0; // Secondary block on top
        const primaryRow = 1;   // Primary block below
        const primaryCol = chosenCol;
        const secondaryCol = chosenCol;

        combo = 0;
        updateComboDisplay();

        let pBlockData = {
            finalRow: primaryRow,
            finalCol: primaryCol,
            color: currentPair.primary,
            isPrimary: true,
            id: Date.now() + '_ap_p'
        };
        let sBlockData = {
            finalRow: secondaryRow,
            finalCol: secondaryCol,
            color: currentPair.secondary,
            isPrimary: false,
            id: Date.now() + '_ap_s'
        };

        playfield[pBlockData.finalRow][pBlockData.finalCol] = { color: pBlockData.color, isPrimary: pBlockData.isPrimary, id: pBlockData.id };
        playfield[sBlockData.finalRow][sBlockData.finalCol] = { color: sBlockData.color, isPrimary: sBlockData.isPrimary, id: sBlockData.id };

         await Promise.all([
            (async (data) => {
                const visualBlock = createVisualBlock(data.color, data.finalRow, data.finalCol, data.isPrimary, data.id);
                visualBlock.style.transition = 'none';
                playfieldElement.appendChild(visualBlock);
                void visualBlock.offsetWidth;
                visualBlock.style.transition = 'top 0.05s linear, left 0.06s linear, opacity 0.2s linear';
                return visualBlock;
            })(pBlockData),
             (async (data) => {
                const visualBlock = createVisualBlock(data.color, data.finalRow, data.finalCol, data.isPrimary, data.id);
                visualBlock.style.transition = 'none';
                playfieldElement.appendChild(visualBlock);
                void visualBlock.offsetWidth;
                visualBlock.style.transition = 'top 0.05s linear, left 0.06s linear, opacity 0.2s linear';
                return visualBlock;
            })(sBlockData)
        ]);
         currentPressureTimeLimit = currentPressureTimeLimit > PRESSURE_MODE_THRESHOLD_TIME ? currentPressureTimeLimit - PRESSURE_MODE_DECREMENT : Math.max(PRESSURE_MODE_MIN_TIME, currentPressureTimeLimit - Math.trunc(PRESSURE_MODE_DECREMENT/10));

        generateNewPair(); // Generate new pair AFTER auto-placement
        await handleGravityAndMatches();

        if (isGameOver()) {
             handleGameOver();
        } else {
             allowInput = true;
             startPressureTurnTimer();
        }
    }


    function isGameOver() {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (!playfield[r][c]) { // Found an empty cell
                    // Check if any adjacent cell (for secondary block) is also empty
                    const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // Up, Down, Left, Right
                    for (const [dr, dc] of dirs) {
                        const sr = r + dr; // Secondary row
                        const sc = c + dc; // Secondary col
                        if (isValidCell(sr, sc) && !playfield[sr][sc]) {
                            return false; // Found a valid placement for a pair
                        }
                    }
                }
            }
        }
        // If we iterate through the whole board and find no valid placement for a pair
        return true;
    }

    function handleGameOver() {
        console.log("Game Over!");
        allowInput = false;
        isFalling = true; // Set to true to prevent any lingering input processing
        if (gameTimerInterval) clearInterval(gameTimerInterval);
        if (pressureTimerInterval) clearTimeout(pressureTimerInterval);
		confirmEndGameModal.style.display = 'none';

        const currentTranslations = translations[currentLanguage] || translations.en;

        finalScoreDisplay.textContent = score;
        finalScoreLine.style.display = 'block';

        maxcomboDisplay.textContent = maxcombo;
        maxcomboLine.style.display = 'block';

        const oldHighScore = getHighScore(gameMode);
        if (score > oldHighScore) {
            setHighScore(gameMode, score);
            highscoreMessageLine.innerHTML = currentTranslations.newHighScoreMsg;
            highscoreMessageLine.style.display = 'block';
            finalHighscoreDisplay.textContent = score; // Ensure this is updated
            currentHighScore = score;
        } else {
            highscoreMessageLine.innerHTML = `${currentTranslations.highScoreMsgPrefix}<span id="final-highscore">${oldHighScore}</span>`;
            highscoreMessageLine.style.display = 'block';
            finalHighscoreDisplay.textContent = oldHighScore; // Ensure this is updated
        }

        gameInterface.style.display = 'flex'; // Keep game interface visible behind modal
        gameOverModal.style.display = 'flex';
    }

    function updateScoreDisplay() {
        scoreDisplay.textContent = score;
    }

    function updateComboDisplay() {
        const currentTranslations = translations[currentLanguage] || translations.en;
        const comboAreaLabel = document.querySelector('#combo-area .label');
        if (comboAreaLabel) {
            comboAreaLabel.textContent = currentTranslations.comboLabelText;
        }

        const comboValueDisplay = document.getElementById('combo-value-display');
        if (combo > 1) {
            comboValueDisplay.textContent = `${combo}x!`;
        } else {
            comboValueDisplay.textContent = `${combo}x`;
        }
    }


    relaxModeBtn.addEventListener('click', () => {
        gameMode = 'relax';
        initGame();
    });
    timedModeBtn.addEventListener('click', () => {
        gameMode = 'timed';
        initGame();
    });
    pressureModeBtn.addEventListener('click', () => {
        gameMode = 'pressure';
		currentPressureTimeLimit = PRESSURE_MODE_INITIAL_TIME;
        initGame();
    });

    howToPlayBtn.addEventListener('click', () => {
        howToPlayModal.style.display = 'flex';
    });

    closeHowToPlayBtn.addEventListener('click', () => {
        howToPlayModal.style.display = 'none';
    });

    mainmenuBtn.addEventListener('click', () => {
        gameOverModal.style.display = 'none';
        gameInterface.style.display = 'none';
        savePairBtn.style.display = 'none';
		confirmEndGameModal.style.display = 'none';
        modeSelectionModal.style.display = 'flex';
		allowInput = false;
        loadLanguage();
    });

    endgameBtn.addEventListener('click', () => {
		confirmEndGameModal.style.display = 'flex';
		gameInterface.style.display = 'none';
		allowInput = false;
    });
	
	confirmEndGameYesBtn.addEventListener('click', () => {
        confirmEndGameModal.style.display = 'none';
        handleGameOver();
		allowInput = false;
    });

    confirmEndGameNoBtn.addEventListener('click', () => {
        confirmEndGameModal.style.display = 'none';
		gameInterface.style.display = 'flex';
		allowInput = true;
    });

    savePairBtn.addEventListener('click', () => {
        if (!allowInput || isFalling) return;

        if (!savedPair || !savedPair.primary) { // No pair saved yet
            savedPair = { ...currentPair };
            generateNewPair(); // Get a new current pair
        } else { // Swap
            const tempCurrentPair = { ...currentPair };
            currentPair = { ...savedPair };
            savedPair = tempCurrentPair;
        }

        updatePreviewDisplays();
        updateSavedPairDisplay();
    });

    // Initial setup:
    loadLanguage();
    modeSelectionModal.style.display = 'flex';
    savePairBtn.style.display = 'none'; // Hide save button initially
    allowInput = false; // Ensure input is off until a game mode is selected
});
</script>
</body>
</html>